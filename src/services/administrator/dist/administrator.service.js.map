{"version":3,"sources":["administrator.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yCAA4C;AAC5C,2CAAmD;AACnD,sEAA8D;AAI9D,kEAA0D;AAK1D;IACI,8BAEqB,aAAwC;QAAxC,kBAAa,GAAb,aAAa,CAA2B;IAG3D,CAAC;IACJ,qCAAqC;IACpC,qCAAM,GAAN;QACI,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IAErC,CAAC;IACA,sCAAO,GAAP,UAAQ,EAAU;QACf,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAE1C,CAAC;IAED,kCAAG,GAAH,UAAI,IAAyB;QAA7B,iBAuBC;QAtBG,IAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;QACjC,IAAM,YAAY,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QACjD,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEnC,IAAM,kBAAkB,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC;QAEpE,IAAI,QAAQ,GAAkB,IAAI,oCAAa,EAAE,CAAC;QAClD,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAClC,QAAQ,CAAC,YAAY,GAAG,kBAAkB,CAAC;QAE3C,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO;YACtB,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC;iBACjC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,OAAO,CAAC,IAAI,CAAC,EAAb,CAAa,CAAC,CAC3B,OAAK,CAAA,CAAC,UAAA,KAAK;gBACR,IAAM,QAAQ,GAAe,IAAI,gCAAW,CAAC,OAAO,EAAC,CAAC,IAAI,CAAC,CAAA;gBAC3D,OAAO,CAAC,QAAQ,CAAC,CAAC;YAEtB,CAAC,CAAC,CAAC;QAGP,CAAC,CAAC,CAAC;IAEP,CAAC;IAEK,uCAAQ,GAAd,UAAe,EAAW,EAAE,IAA0B;uCAAG,OAAO;;;;4BACjC,qBAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC,EAAA;;wBAA3D,KAAK,GAAkB,SAAoC;wBAE/D,IAAG,KAAK,KAAG,SAAS,EAAC;4BACjB,sBAAO,IAAI,OAAO,CAAC,UAAC,OAAO;oCACvB,OAAO,CAAC,IAAI,gCAAW,CAAC,OAAO,EAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gCAC5C,CAAC,CAAC,EAAA;yBACL;wBAEK,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;wBAC3B,YAAY,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;wBACjD,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAE7B,kBAAkB,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC;wBAGpE,KAAK,CAAC,YAAY,GAAG,kBAAkB,CAAC;wBACxC,sBAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,EAAC;;;;KACzC;IA5DQ,oBAAoB;QADhC,mBAAU,EAAE;QAGJ,WAAA,0BAAgB,CAAC,oCAAa,CAAC,CAAA;OAF3B,oBAAoB,CAgEhC;IAAD,2BAAC;CAhED,AAgEC,IAAA;AAhEY,oDAAoB;AAkEjC,SAAS,IAAI,CAAC,IAAyB;IACnC,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;AACjD,CAAC","file":"administrator.service.js","sourcesContent":["import { Injectable } from \"@nestjs/common\";\nimport { InjectRepository } from \"@nestjs/typeorm\";\nimport { Administrator } from \"entities/administrator.entity\";\nimport { resolve } from \"path\";\nimport { AddAdministratorDto } from \"src/dtos/administrator/add.administrator.dto\";\nimport { EditAdministratorDto } from \"src/dtos/administrator/edit.administrator.dto\";\nimport { ApiResponse } from \"src/misc/api.response.class\";\nimport { Repository } from \"typeorm\" ;\n\n\n@Injectable()\nexport class AdministratorService{\n    constructor(\n        @InjectRepository(Administrator)\n        private readonly administrator: Repository<Administrator>,\n\n\n    ){}\n   //funkcija vraca niz administratora//\n    getAll():Promise<Administrator[]> {\n        return this.administrator.find();\n\n    }\n     getById(id: number ): Promise<Administrator>{\n        return this.administrator.findOne(id);\n\n    }\n\n    add(data: AddAdministratorDto): Promise<Administrator | ApiResponse>{\n        const crypto = require('crypto');\n        const passwordHash = crypto.createHash('sha512');\n        passwordHash.update(data.password);\n\n        const passwordHashString = passwordHash.digest('hex').toUpperCase();\n\n        let newAdmin: Administrator = new Administrator();\n        newAdmin.username = data.username;\n        newAdmin.passwordHash = passwordHashString;\n\n        return new Promise((resolve) =>{\n             this.administrator.save(newAdmin)\n            .then(data => resolve(data))\n            .catch(error =>{\n                const response:ApiResponse = new ApiResponse(\"error\",-1001)\n                resolve(response);\n\n            });\n            \n        \n        });\n\n    }\n\n    async editById(id : number, data: EditAdministratorDto): Promise<Administrator | ApiResponse>{\n        let admin: Administrator = await this.administrator.findOne(id);\n\n        if(admin===undefined){\n            return new Promise((reslove) =>{\n                reslove(new ApiResponse(\"error\",-1002));\n            })\n        }\n\n        const crypto = require('crypto');\n        const passwordHash = crypto.createHash('sha512');\n        passwordHash.update(data.password);\n\n        const passwordHashString = passwordHash.digest('hex').toUpperCase();\n\n\n        admin.passwordHash = passwordHashString;\n        return this.administrator.save(admin);\n    }\n\n    \n\n}\n\nfunction then(arg0: (data: any) => void) {\n    throw new Error(\"Function not implemented.\");\n}\n\n"]}