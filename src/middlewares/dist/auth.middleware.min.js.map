{"version":3,"sources":["auth.middleware.ts"],"names":["common_1","require","jwt","jwt_secret_1","decorators_1","AuthMidleware","administratorService","this","prototype","use","req","res","next","headers","authorization","HttpException","HttpStatus","UNAUTHORIZED","token","tokenParts","split","length","tokenString","jwtData","verify","jwtSecret","ip","toString","getById","administratorId","_a","sent","Date","getTime","ext","__decorate","Injectable","exports"],"mappings":"+xDAAA,IAAAA,SAAAC,QAAA,kBAGAC,IAAAD,QAAA,gBACAE,aAAAF,QAAA,qBAEAG,aAAAH,QAAA,6BAGAI,cAAA,WACI,SAAAA,EAA6BC,GAAAC,KAAAD,qBAAAA,EAwCjC,OAvCUD,EAAAG,UAAAC,IAAN,SAAUC,EAAcC,EAAeC,yHAEnC,IAAKF,EAAIG,QAAQC,cACb,MAAM,IAAId,SAAAe,cAAc,kBAAkBf,SAAAgB,WAAWC,cAOzD,GAHMC,EAAQR,EAAIG,QAAQC,cAGD,KADnBK,EAAaD,EAAME,MAAM,MACjBC,OACV,MAAM,IAAIrB,SAAAe,cAAc,mBAAoBf,SAAAgB,WAAWC,cAK3D,GAHMK,EAAcH,EAAW,KACzBI,EAAkCrB,IAAIsB,OAAOF,EAAanB,aAAAsB,YAG5D,MAAM,IAAIzB,SAAAe,cAAc,mBAAoBf,SAAAgB,WAAWC,cAM1D,GAFUP,EAAIgB,GAAGC,WAEdJ,EAAQG,KAAOhB,EAAIgB,GAAGC,WACvB,MAAM,IAAI3B,SAAAe,cAAc,mBAAoBf,SAAAgB,WAAWC,cAEpC,MAAA,CAAA,EAAMV,KAAKD,qBAAqBsB,QAAQL,EAAQM,yBACtE,IADsBC,EAAAC,OAElB,MAAM,IAAI/B,SAAAe,cAAc,oBAAqBf,SAAAgB,WAAWC,cAG5D,IAD0B,IAAIe,MAAOC,UAAY,KACxBV,EAAQW,IAC7B,MAAM,IAAIlC,SAAAe,cAAc,wBAAwBf,SAAAgB,WAAWC,qBAI/DL,cAtCKP,EAAa8B,WAAA,CADzB/B,aAAAgC,cACY/B,GAAb,GAAagC,QAAAhC,cAAAA","file":"auth.middleware.min.js","sourcesContent":["import { HttpException, HttpStatus, NestMiddleware } from \"@nestjs/common\";\r\nimport { NextFunction, Request, Response } from \"express\";\r\nimport { AdministratorService } from \"src/services/administrator/administrator.service\";\r\nimport * as jwt from 'jsonwebtoken';\r\nimport { jwtSecret } from \"config/jwt.secret\";\r\nimport { JwtDataAdministatorDto } from \"src/dtos/administrator/jwt.data.administrator.dto\";\r\nimport { Injectable } from \"@nestjs/common/decorators\";\r\n\r\n@Injectable()\r\nexport class AuthMidleware implements NestMiddleware{\r\n    constructor(private readonly administratorService: AdministratorService){}\r\n    async use(req: Request, res: Response, next: NextFunction) {\r\n        \r\n        if (!req.headers.authorization){\r\n            throw new HttpException('Token not found',HttpStatus.UNAUTHORIZED);\r\n        }\r\n        \r\n\r\n        const token = req.headers.authorization;\r\n\r\n        const tokenParts = token.split(' ');\r\n        if(tokenParts.length !== 2){\r\n            throw new HttpException('Bad token found1', HttpStatus.UNAUTHORIZED)\r\n        }\r\n        const tokenString = tokenParts[1];\r\n        const jwtData: JwtDataAdministatorDto = jwt.verify(tokenString, jwtSecret) as any ;\r\n\r\n        if(!jwtData){\r\n            throw new HttpException('Bad token found2', HttpStatus.UNAUTHORIZED)\r\n        }\r\n\r\n        \r\n        const ip = req.ip.toString();\r\n\r\n         if(jwtData.ip !== req.ip.toString()){\r\n           throw new HttpException('Bad token found3', HttpStatus.UNAUTHORIZED);\r\n        }\r\n        const administrator = await this.administratorService.getById(jwtData.administratorId)\r\n        if(!administrator){\r\n            throw new HttpException('Account not found', HttpStatus.UNAUTHORIZED);\r\n        }\r\n        const trenutniTimestamp = new Date().getTime() / 1000;\r\n        if (trenutniTimestamp >= jwtData.ext) {\r\n            throw new HttpException('the token has expired',HttpStatus.UNAUTHORIZED)\r\n        }\r\n\r\n\r\n        next();\r\n    }\r\n    \r\n}"]}